import React, { useState, useEffect, useRef, ChangeEvent } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { 
  Star, 
  X, 
  Bold, 
  Italic, 
  Underline, 
  Type,
  AlignLeft,
  AlignCenter,
  AlignRight,
  Calendar,
  ChevronDown,
  Mic,
  MicOff,
  FileImage,
  FileText,
  Download,
  FileVideo,
  FileAudio
} from "lucide-react";
import { toast } from "sonner";
import { format } from 'date-fns';
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Calendar as CalendarComponent } from "@/components/ui/calendar";
import { Slider } from "@/components/ui/slider";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import html2canvas from 'html2canvas';
import jsPDF from 'jspdf';

// TypeScript declarations for Web Speech API
declare global {
  interface Window {
    SpeechRecognition: any;
    webkitSpeechRecognition: any;
  }
}

interface SpeechRecognitionErrorEvent extends Event {
  error: string;
}

interface AttachedFile {
  id: string;
  name: string;
  type: string;
  url: string;
  width?: number;
  height?: number;
  position?: { x: number; y: number };
}

interface JournalEntryProps {}

const JournalEntry: React.FC<JournalEntryProps> = () => {
  const navigate = useNavigate();
  const { id } = useParams<{ id: string }>();
  const isEditMode = id !== undefined;
  
  // State for the journal entry
  const [title, setTitle] = useState<string>('');
  const [content, setContent] = useState<string>('');
  const [isEnhancing, setIsEnhancing] = useState<boolean>(false);
  const [enhanceProgress, setEnhanceProgress] = useState<number>(0);
  const [textAlign, setTextAlign] = useState<string>('left');
  const [fontSize, setFontSize] = useState<number>(16);
  const [fontFamily, setFontFamily] = useState<string>('Times New Roman');
  const [selectedDate, setSelectedDate] = useState<Date | undefined>(new Date());
  const [wordCount, setWordCount] = useState<number>(0);
  const [charCount, setCharCount] = useState<number>(0);
  const [titleError, setTitleError] = useState<string>('');
  const [contentError, setContentError] = useState<string>('');
  const [isSaving, setIsSaving] = useState<boolean>(false);
  const [lastSaved, setLastSaved] = useState<Date | null>(null);
  const [showFontSizeSlider, setShowFontSizeSlider] = useState<boolean>(false);
  
  // Voice typing state
  const [isVoiceTyping, setIsVoiceTyping] = useState<boolean>(false);
  const [recognition, setRecognition] = useState<SpeechRecognition | null>(null);
  
  // File attachment state
  const [attachedFiles, setAttachedFiles] = useState<AttachedFile[]>([]);
  const [isDraggingFile, setIsDraggingFile] = useState<string | null>(null);
  const [activeFileMenu, setActiveFileMenu] = useState<string | null>(null);
  
  // Export state
  const [isExporting, setIsExporting] = useState<boolean>(false);
  const [exportFormat, setExportFormat] = useState<string>('');
  
  // Available fonts
  const availableFonts = [
    { name: "Times New Roman", class: "font-times" },
    { name: "Arial", class: "font-sans" },
    { name: "Georgia", class: "font-serif" },
    { name: "Courier New", class: "font-mono" },
    { name: "Verdana", class: "font-sans" },
    { name: "Tahoma", class: "font-sans" },
    { name: "Trebuchet MS", class: "font-sans" }
  ];
  
  // Font size presets
  const fontSizePresets = [
    { name: "Small", size: 14 },
    { name: "Medium", size: 16 },
    { name: "Large", size: 18 },
    { name: "Extra Large", size: 24 }
  ];
  
  // Auto-save timer ref
  const autoSaveTimerRef = useRef<NodeJS.Timeout | null>(null);
  
  // References
  const contentEditableRef = useRef<HTMLDivElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const journalCardRef = useRef<HTMLDivElement>(null);

  // Hide sidebar when component mounts
  useEffect(() => {
    // Hide sidebar by adding a class to the body
    document.body.classList.add('hide-sidebar');
    
    // Clean up when component unmounts
    return () => {
      document.body.classList.remove('hide-sidebar');
      // Stop voice recognition if it's still going
      if (recognition) {
        recognition.stop();
      }
    };
  }, [recognition]);

  // Effect to load data if editing
  useEffect(() => {
    if (isEditMode && id) {
      loadEntry(id);
    }
  }, [id]);
  
  // Effect to update word and character count
  useEffect(() => {
    if (contentEditableRef.current) {
      const text = contentEditableRef.current.innerText || '';
      const words = text.trim() ? text.trim().split(/\s+/).length : 0;
      const chars = text.length;
      
      setWordCount(words);
      setCharCount(chars);
    }
  }, [content]);
  
  // Effect to handle auto-save
  useEffect(() => {
    // Set up auto-save
    if (autoSaveTimerRef.current) {
      clearTimeout(autoSaveTimerRef.current);
    }
    
    autoSaveTimerRef.current = setTimeout(() => {
      if (contentEditableRef.current && (title.trim() || contentEditableRef.current.innerHTML.trim()) && !isSaving) {
        autoSave();
      }
    }, 10000); // Auto-save every 10 seconds
    
    return () => {
      if (autoSaveTimerRef.current) {
        clearTimeout(autoSaveTimerRef.current);
      }
    };
  }, [title, content, isSaving, attachedFiles]);

  // Setup speech recognition
  useEffect(() => {
    if (typeof window !== 'undefined' && 'SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      const recognition = new SpeechRecognition();
      
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = 'en-US';
      
      recognition.onresult = (event: SpeechRecognitionEvent) => {
        let interimTranscript = '';
        let finalTranscript = '';
        
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            finalTranscript += transcript;
          } else {
            interimTranscript += transcript;
          }
        }
        
        // Process transcript for punctuation commands
        const processedTranscript = processSpeechCommands(finalTranscript);
        
        if (processedTranscript && contentEditableRef.current) {
          // Insert at cursor position if possible
          const selection = window.getSelection();
          if (selection && selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            if (contentEditableRef.current.contains(range.commonAncestorContainer)) {
              // Insert the text at cursor position
              const textNode = document.createTextNode(processedTranscript + ' ');
              range.insertNode(textNode);
              
              // Move cursor to the end of inserted text
              range.setStartAfter(textNode);
              range.setEndAfter(textNode);
              selection.removeAllRanges();
              selection.addRange(range);
              
              // Trigger content change event
              handleContentChange();
            }
          } else {
            // If no selection, append to the end
            contentEditableRef.current.innerHTML += processedTranscript + ' ';
            handleContentChange();
          }
        }
      };
      
      recognition.onerror = (event: SpeechRecognitionErrorEvent) => {
        console.error('Speech recognition error', event.error);
        if (event.error === 'not-allowed') {
          toast.error('Microphone access was denied. Please allow access to use voice typing.');
        } else {
          toast.error('Voice typing error. Please try again.');
        }
        setIsVoiceTyping(false);
      };
      
      recognition.onend = () => {
        // Only set voice typing to false if user manually stopped it
        if (isVoiceTyping) {
          // Try to restart if it ended unexpectedly
          try {
            recognition.start();
          } catch (e) {
            console.error('Error restarting recognition', e);
            setIsVoiceTyping(false);
          }
        }
      };
      
      setRecognition(recognition);
    }
  }, [isVoiceTyping]);

  // Effect to detect export parameters from URL
  useEffect(() => {
    if (typeof window !== 'undefined') {
      const queryParams = new URLSearchParams(window.location.search);
      const action = queryParams.get('action');
      const exportFormat = queryParams.get('format');
      
      if (action === 'export' && exportFormat && id) {
        // Load entry first, then export
        if (isEditMode && id) {
          const loadAndExport = async () => {
            try {
              // Load journal entries from localStorage
              const savedEntries = localStorage.getItem('journalEntries');
              if (savedEntries) {
                const entries = JSON.parse(savedEntries);
                const entry = entries.find((e: any) => e.id === id);
                
                if (entry) {
                  // Set entry data to state
                  setTitle(entry.title);
                  setContent(entry.content || '');
                  if (entry.textAlign) setTextAlign(entry.textAlign);
                  if (entry.fontSize) setFontSize(entry.fontSize);
                  if (entry.fontFamily) setFontFamily(entry.fontFamily);
                  if (entry.date) setSelectedDate(new Date(entry.date));
                  if (entry.attachedFiles) setAttachedFiles(entry.attachedFiles);
                  
                  // Wait for next render cycle to ensure content is loaded
                  setTimeout(() => {
                    // Set content to the editable div
                    if (contentEditableRef.current && entry.content) {
                      contentEditableRef.current.innerHTML = entry.content;
                    }
                    
                    // Wait a moment to ensure UI is rendered
                    setTimeout(() => {
                      // Export the entry
                      exportJournalEntry(exportFormat);
                      
                      // Navigate back to journal after export
                      setTimeout(() => {
                        navigate('/journal');
                      }, 1000);
                    }, 300);
                  }, 200);
                } else {
                  toast.error("Entry not found");
                  navigate('/journal');
                }
              }
            } catch (error) {
              console.error("Error exporting entry:", error);
              toast.error("Error exporting entry");
              navigate('/journal');
            }
          };
          
          loadAndExport();
        }
      }
    }
  }, [id, isEditMode, navigate]);

  const loadEntry = (entryId: string) => {
    try {
      // Load journal entries from localStorage
      const savedEntries = localStorage.getItem('journalEntries');
      if (savedEntries) {
        const entries = JSON.parse(savedEntries);
        const entry = entries.find((e: any) => e.id === entryId);
        
        if (entry) {
          setTitle(entry.title);
          setContent(entry.content || '');
          if (entry.textAlign) setTextAlign(entry.textAlign);
          if (entry.fontSize) setFontSize(entry.fontSize);
          if (entry.fontFamily) setFontFamily(entry.fontFamily);
          if (entry.date) setSelectedDate(new Date(entry.date));
          if (entry.attachedFiles) setAttachedFiles(entry.attachedFiles);
          
          // Set the content to the editable div after DOM is ready
          setTimeout(() => {
            if (contentEditableRef.current && entry.content) {
              contentEditableRef.current.innerHTML = entry.content;
            }
          }, 100);
        } else {
          toast.error("Entry not found");
          navigate('/journal');
        }
      }
    } catch (error) {
      console.error("Error loading entry:", error);
      toast.error("Error loading entry");
      navigate('/journal');
    }
  };
  
  // Process speech commands for punctuation
  const processSpeechCommands = (transcript: string): string => {
    // Replace punctuation commands with actual punctuation
    let processed = transcript
      .replace(/\bperiod\b/gi, '.')
      .replace(/\bcomma\b/gi, ',')
      .replace(/\bquestion mark\b/gi, '?')
      .replace(/\bexclamation\b/gi, '!')
      .replace(/\bexclamation point\b/gi, '!')
      .replace(/\bexclamation mark\b/gi, '!')
      .replace(/\bnew line\b/gi, '\n')
      .replace(/\bnewline\b/gi, '\n')
      .replace(/\bcolon\b/gi, ':')
      .replace(/\bsemicolon\b/gi, ';')
      .replace(/\bquote\b/gi, '"')
      .replace(/\bopen quote\b/gi, '"')
      .replace(/\bclose quote\b/gi, '"')
      .replace(/\bopen bracket\b/gi, '(')
      .replace(/\bclose bracket\b/gi, ')')
      .replace(/\bhyphen\b/gi, '-')
      .replace(/\bdash\b/gi, '-');
    
    return processed;
  };
  
  const toggleVoiceTyping = () => {
    if (!recognition) {
      toast.error('Speech recognition is not supported in your browser');
      return;
    }

    if (isVoiceTyping) {
      // Stop voice typing
      recognition.stop();
      setIsVoiceTyping(false);
      toast.success('Voice typing stopped');
    } else {
      // Focus the content area before starting
      if (contentEditableRef.current) {
        contentEditableRef.current.focus();
      }
      
      // Start voice typing
      try {
        recognition.start();
        setIsVoiceTyping(true);
        toast.success('Voice typing started - speak now');
      } catch (error) {
        console.error('Error starting speech recognition', error);
        toast.error('Could not start voice typing. Please try again.');
      }
    }
  };
  
  const handleFileUpload = (event: ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files;
    if (!files || files.length === 0) return;
    
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      
      // Check file size (limit to 10MB)
      if (file.size > 10 * 1024 * 1024) {
        toast.error(`File ${file.name} is too large. Maximum size is 10MB.`);
        continue;
      }
      
      const reader = new FileReader();
      
      reader.onload = (e) => {
        const result = e.target?.result as string;
        
        // Create a new attached file object
        const newFile: AttachedFile = {
          id: `file-${Date.now()}-${i}`,
          name: file.name,
          type: file.type,
          url: result,
          // Default position in the middle of the content
          position: { x: 50, y: 50 }
        };
        
        // If it's an image, get dimensions
        if (file.type.startsWith('image/')) {
          const img = new Image();
          img.onload = () => {
            const updatedFile = { ...newFile, width: img.width, height: img.height };
            setAttachedFiles(prev => [...prev, updatedFile]);
          };
          img.src = result;
        } else {
          setAttachedFiles(prev => [...prev, newFile]);
        }
      };
      
      reader.onerror = () => {
        toast.error(`Error reading file ${file.name}`);
      };
      
      // Read file as data URL
      reader.readAsDataURL(file);
    }
    
    // Clear the input to allow uploading the same file again
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };
  
  const handleFileDragStart = (fileId: string) => {
    setIsDraggingFile(fileId);
  };
  
  const handleFileDrag = (event: React.MouseEvent<HTMLDivElement>, fileId: string) => {
    if (isDraggingFile !== fileId) return;
    
    const contentRect = contentEditableRef.current?.getBoundingClientRect();
    if (!contentRect) return;
    
    // Get mouse position relative to content area
    const x = ((event.clientX - contentRect.left) / contentRect.width) * 100;
    const y = ((event.clientY - contentRect.top) / contentRect.height) * 100;
    
    // Update file position
    setAttachedFiles(prev => 
      prev.map(file => 
        file.id === fileId ? {...file, position: { x, y }} : file
      )
    );
  };
  
  const handleFileDragEnd = () => {
    setIsDraggingFile(null);
  };
  
  const deleteAttachedFile = (fileId: string) => {
    setAttachedFiles(prev => prev.filter(file => file.id !== fileId));
    setActiveFileMenu(null);
  };
  
  const exportJournalEntry = (format: string) => {
    setIsExporting(true);
    setExportFormat(format);
    
    if (!journalCardRef.current) {
      toast.error('Could not export journal entry');
      setIsExporting(false);
      return;
    }
    
    setTimeout(async () => {
      try {
        switch (format) {
          case 'image': {
            const canvas = await html2canvas(journalCardRef.current as HTMLElement, {
              scale: 2, // Higher quality
              useCORS: true,
              allowTaint: true,
              backgroundColor: '#fff'
            });
            
            const imageUrl = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            const formattedDate = format(new Date(), 'yyyy-MM-dd');
            const fileName = `${title.replace(/[^a-z0-9]/gi, '-').toLowerCase()}-${formattedDate}.png`;
            link.download = fileName;
            link.href = imageUrl;
            link.click();
            break;
          }
          
          case 'pdf': {
            const canvas = await html2canvas(journalCardRef.current as HTMLElement, {
              scale: 2,
              useCORS: true,
              allowTaint: true,
              backgroundColor: '#fff'
            });
            
            const imgData = canvas.toDataURL('image/png');
            const pdf = new jsPDF({
              orientation: 'portrait',
              unit: 'mm',
              format: 'a4'
            });
            
            // Calculate dimensions for fitting the image on the page
            const imgWidth = 210; // A4 width in mm
            const imgHeight = (canvas.height * imgWidth) / canvas.width;
            
            pdf.addImage(imgData, 'PNG', 0, 0, imgWidth, imgHeight);
            const formattedDate = format(new Date(), 'yyyy-MM-dd');
            const fileName = `${title.replace(/[^a-z0-9]/gi, '-').toLowerCase()}-${formattedDate}.pdf`;
            pdf.save(fileName);
            break;
          }
          
          case 'html': {
            // Create a clone of the entry to style and download
            const entryClone = journalCardRef.current.cloneNode(true) as HTMLElement;
            
            // Create a new document with proper styling
            const html = `
              <!DOCTYPE html>
              <html lang="en">
              <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>${title}</title>
                <style>
                  body {
                    font-family: ${fontFamily}, serif;
                    max-width: 800px;
                    margin: 0 auto;
                    padding: 20px;
                    background-color: #fff;
                    color: #333;
                  }
                  .journal-title {
                    font-size: 32px;
                    font-weight: bold;
                    margin-bottom: 20px;
                  }
                  .journal-content {
                    font-size: ${fontSize}px;
                    line-height: 1.6;
                    text-align: ${textAlign};
                  }
                  .journal-meta {
                    font-size: 14px;
                    color: #666;
                    margin-top: 30px;
                  }
                  .journal-date {
                    font-style: italic;
                  }
                  .attached-file {
                    max-width: 100%;
                    margin: 15px 0;
                    border-radius: 4px;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                  }
                  .file-container {
                    display: block;
                    margin: 15px 0;
                  }
                </style>
              </head>
              <body>
                <div class="journal-title">${title}</div>
                <div class="journal-content">${contentEditableRef.current?.innerHTML || ''}</div>
                ${attachedFiles.map(file => {
                  if (file.type.startsWith('image/')) {
                    return `<img src="${file.url}" alt="${file.name}" class="attached-file">`;
                  } else if (file.type.startsWith('video/')) {
                    return `<video controls src="${file.url}" class="attached-file"></video>`;
                  } else if (file.type.startsWith('audio/')) {
                    return `<audio controls src="${file.url}" class="attached-file"></audio>`;
                  } else {
                    return `<div class="file-container">File: ${file.name}</div>`;
                  }
                }).join('')}
                <div class="journal-meta">
                  <div class="journal-date">Date: ${selectedDate ? format(selectedDate, 'PPP') : 'Unknown'}</div>
                  <div>${wordCount} words · ${charCount} characters</div>
                </div>
              </body>
              </html>
            `;
            
            // HTML export
            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            const formattedDate = format(new Date(), 'yyyy-MM-dd');
            const fileName = `${title.replace(/[^a-z0-9]/gi, '-').toLowerCase()}-${formattedDate}.html`;
            link.download = fileName;
            link.href = url;
            link.click();
            
            // Clean up
            URL.revokeObjectURL(url);
            break;
          }
          
          default:
            toast.error('Invalid export format');
        }
        
        toast.success(`Journal entry exported as ${format}`);
      } catch (error) {
        console.error('Error exporting journal entry:', error);
        toast.error('Failed to export journal entry');
      } finally {
        setIsExporting(false);
        setExportFormat('');
      }
    }, 100);
  };
  
  const validateFields = () => {
    let isValid = true;
    
    // Validate title
    if (!title.trim()) {
      setTitleError("Title cannot be empty");
      isValid = false;
    } else {
      setTitleError("");
    }
    
    // Validate content
    const contentText = contentEditableRef.current?.innerHTML || '';
    if (!contentText.trim()) {
      setContentError("Content cannot be empty");
      isValid = false;
    } else {
      setContentError("");
    }
    
    return isValid;
  };

  const handleSave = (shouldNavigateBack: boolean = true) => {
    if (!validateFields()) {
      toast.error("Please fill in all required fields");
      return false;
    }
    
    setIsSaving(true);
    
    try {
      // Get current HTML content
      const contentHTML = contentEditableRef.current?.innerHTML || '';
      
      // Get existing entries
      const savedEntries = localStorage.getItem('journalEntries');
      const entries = savedEntries ? JSON.parse(savedEntries) : [];
      
      // Create new entry object
      const newEntry = {
        id: isEditMode && id ? id : Date.now().toString(),
        date: selectedDate || new Date(),
        title: title,
        content: contentHTML,
        textAlign: textAlign,
        fontSize: fontSize,
        fontFamily: fontFamily,
        tags: [],
        isFavorite: false,
        wordCount,
        charCount,
        attachedFiles,
        createdAt: isEditMode ? undefined : new Date(),
        updatedAt: new Date()
      };
      
      let updatedEntries;
      
      if (isEditMode && id) {
        // Update existing entry
        updatedEntries = entries.map((entry: any) => 
          entry.id === id ? { ...entry, ...newEntry } : entry
        );
      } else {
        // Add new entry
        updatedEntries = [newEntry, ...entries];
      }
      
      // Save to localStorage
      localStorage.setItem('journalEntries', JSON.stringify(updatedEntries));
      
      // Update last saved time
      setLastSaved(new Date());
      setIsSaving(false);
      
      toast.success(isEditMode ? "Journal entry updated" : "Journal entry saved");
      
      if (shouldNavigateBack) {
        navigate('/journal');
      }
      
      return true;
    } catch (error) {
      console.error("Error saving entry:", error);
      toast.error("Unable to save entry. Check your connection and try again.");
      setIsSaving(false);
      return false;
    }
  };
  
  const autoSave = () => {
    // Only auto-save if there's content
    if (contentEditableRef.current?.innerHTML.trim() || title.trim()) {
      handleSave(false);
    }
  };
  
  const handleClose = () => {
    navigate('/journal');
  };

  const handleEnhance = async () => {
    if (!contentEditableRef.current?.textContent?.trim()) {
      toast.error("Please write some content first");
      return;
    }

    setIsEnhancing(true);
    setEnhanceProgress(0);
    
    // Animation progress timer
    const progressInterval = setInterval(() => {
      setEnhanceProgress(prev => {
        if (prev >= 100) {
          clearInterval(progressInterval);
          return 100;
        }
        return prev + 5;
      });
    }, 100);
    
    try {
      // Here we would normally call an AI service API
      // For this demo, we'll simulate an AI enhancement with a timeout
      
      setTimeout(() => {
        clearInterval(progressInterval);
        setEnhanceProgress(100);
        
        // Get current content
        const currentContent = contentEditableRef.current?.innerHTML || '';
        
        // Simulate AI enhanced content
        const enhancedTitle = title ? 
          `${title} - Refined` : 
          `Thoughts on ${format(new Date(), 'MMMM d, yyyy')}`;
        
        const enhancedContent = `<h1 style="font-size: 1.5em; margin-bottom: 0.5em;">${enhancedTitle}</h1><p>${currentContent}</p><h2 style="font-size: 1.25em; margin-top: 1em; margin-bottom: 0.5em;">Reflections</h2><p>As I look back on what I've written, I realize these thoughts reveal important patterns in my life. The experiences I've captured here are valuable stepping stones in my personal journey.</p><p>Taking time to write has helped me gain clarity and perspective. Through this process of reflection, I've come to understand myself a little better today.</p>`;

        setTimeout(() => {
          setTitle(enhancedTitle);
          if (contentEditableRef.current) {
            contentEditableRef.current.innerHTML = enhancedContent;
            // Trigger an input event to update word count
            const event = new Event('input', { bubbles: true });
            contentEditableRef.current.dispatchEvent(event);
          }
          setIsEnhancing(false);
          setEnhanceProgress(0);
          toast.success("Your entry has been enhanced!");
        }, 500);
        
      }, 2000);
      
    } catch (error) {
      clearInterval(progressInterval);
      console.error("Error enhancing entry:", error);
      toast.error("Enhancement failed. Please try again.");
      setIsEnhancing(false);
      setEnhanceProgress(0);
    }
  };

  // Handle formatting commands
  const formatText = (command: string, value: string | null = null) => {
    document.execCommand(command, false, value);
    
    // Focus back on the content
    if (contentEditableRef.current) {
      contentEditableRef.current.focus();
    }
  };

  const handleFontSizeChange = (size: number) => {
    setFontSize(size);
    if (contentEditableRef.current) {
      // Check if text is selected
      const selection = window.getSelection();
      if (selection && selection.rangeCount > 0 && selection.toString().trim() !== '') {
        // Format only selected text
        formatText('fontSize', size / 16 + ''); // Convert to traditional HTML font size
      } else {
        // Apply to entire div if no selection
        contentEditableRef.current.style.fontSize = `${size}px`;
      }
    }
  };

  const handleFontFamilyChange = (font: string) => {
    setFontFamily(font);
    if (contentEditableRef.current) {
      // Check if text is selected
      const selection = window.getSelection();
      if (selection && selection.rangeCount > 0 && selection.toString().trim() !== '') {
        // Format only selected text
        formatText('fontName', font);
      } else {
        // Apply to entire div if no selection
        contentEditableRef.current.style.fontFamily = font;
      }
    }
  };

  const handleAlignment = (align: string) => {
    setTextAlign(align);
    formatText('justifyText' + align.charAt(0).toUpperCase() + align.slice(1)); // e.g., 'justifyTextLeft'
  };

  const handleDateSelect = (date: Date | undefined) => {
    setSelectedDate(date);
    toast.success(`Date selected: ${date ? format(date, 'PPP') : 'None'}`);
  };

  const handleContentChange = () => {
    if (contentEditableRef.current) {
      // Update word and character count
      const text = contentEditableRef.current.innerText || '';
      const words = text.trim() ? text.trim().split(/\s+/).length : 0;
      const chars = text.length;
      
      setWordCount(words);
      setCharCount(chars);
      
      // Clear error if content is not empty
      if (text.trim()) {
        setContentError("");
      }
    }
  };

  // Helper function to get font display name
  const getFontDisplayName = (fontClass: string) => {
    const font = availableFonts.find(f => f.class === fontClass);
    return font ? font.name : 'Default';
  };

  return (
    <div className="min-h-screen flex flex-col bg-[#FFF7ED] text-slate-800 py-10 px-6">
      {/* Hidden file input for file attachments */}
      <input 
        type="file" 
        ref={fileInputRef}
        className="hidden"
        onChange={handleFileUpload}
        multiple
        accept="image/*,video/*,audio/*,application/pdf"
        title="Upload files"
        aria-label="Upload files"
      />
      
      {/* Main content container */}
      <div className="container max-w-2xl mx-auto flex-1 flex flex-col justify-center">
        {/* Main journal container */}
        <Card className="border-none shadow-[0_4px_20px_rgba(0,0,0,0.08)] bg-white rounded-[24px] overflow-hidden animate-fade-in relative" ref={journalCardRef}>
          {/* Close button */}
          <Button
            onClick={handleClose}
            variant="ghost"
            size="sm"
            className="absolute top-4 right-4 h-8 w-8 p-0 rounded-full hover:bg-slate-100 transition-colors z-10"
            aria-label="Close"
          >
            <X className="h-5 w-5 text-slate-600" />
          </Button>
          
          <CardContent className="p-8">
            <div className="flex-1 flex flex-col space-y-6">
              {/* Title input */}
              <div>
                <Input
                  value={title}
                  onChange={(e) => {
                    setTitle(e.target.value);
                    if (e.target.value.trim()) setTitleError("");
                  }}
                  placeholder="Enter your title..."
                  className={`text-3xl font-semibold border-none bg-transparent placeholder:text-slate-400 text-slate-700 focus-visible:ring-0 focus-visible:ring-offset-0 font-times p-0 ${titleError ? 'border-red-500' : ''}`}
                  style={{ fontFamily: fontFamily }}
                />
                {titleError && (
                  <p className="text-red-500 text-xs mt-1">{titleError}</p>
                )}
              </div>
              
              {/* Formatting toolbar */}
              <div className="flex items-center space-x-3 py-2 border-b border-slate-200 flex-wrap">
                <Button 
                  variant="ghost" 
                  size="sm" 
                  onClick={() => formatText('bold')}
                  className="h-8 w-8 p-0 rounded-md hover:bg-slate-100 transition-colors"
                  title="Bold"
                >
                  <Bold className="h-4 w-4 text-slate-600" />
                </Button>
                <Button 
                  variant="ghost" 
                  size="sm" 
                  onClick={() => formatText('italic')}
                  className="h-8 w-8 p-0 rounded-md hover:bg-slate-100 transition-colors"
                  title="Italic"
                >
                  <Italic className="h-4 w-4 text-slate-600" />
                </Button>
                <Button 
                  variant="ghost" 
                  size="sm" 
                  onClick={() => formatText('underline')}
                  className="h-8 w-8 p-0 rounded-md hover:bg-slate-100 transition-colors"
                  title="Underline"
                >
                  <Underline className="h-4 w-4 text-slate-600" />
                </Button>
                <div className="w-px h-5 bg-slate-200" />
                
                {/* Voice typing button */}
                <Button 
                  variant="ghost" 
                  size="sm" 
                  onClick={toggleVoiceTyping}
                  className={`h-8 w-8 p-0 rounded-md hover:bg-slate-100 transition-colors ${isVoiceTyping ? 'bg-purple-100 text-purple-700' : ''}`}
                  title={isVoiceTyping ? "Stop voice typing" : "Start voice typing"}
                >
                  {isVoiceTyping ? (
                    <MicOff className="h-4 w-4 text-purple-600" />
                  ) : (
                    <Mic className="h-4 w-4 text-slate-600" />
                  )}
                </Button>
                
                {/* File attachment button */}
                <Button 
                  variant="ghost" 
                  size="sm" 
                  onClick={() => fileInputRef.current?.click()}
                  className="h-8 w-8 p-0 rounded-md hover:bg-slate-100 transition-colors"
                  title="Add file attachment"
                >
                  <FileImage className="h-4 w-4 text-slate-600" />
                </Button>
                
                <div className="w-px h-5 bg-slate-200" />
                
                {/* Font Size Dropdown */}
                <Popover open={showFontSizeSlider} onOpenChange={setShowFontSizeSlider}>
                  <PopoverTrigger asChild>
                    <Button 
                      variant="ghost" 
                      size="sm"
                      className="h-8 px-2 rounded-md hover:bg-slate-100 transition-colors flex items-center space-x-1"
                      title="Font Size"
                    >
                      <Type className="h-4 w-4 text-slate-600" />
                      <span className="text-xs">{fontSize}px</span>
                    </Button>
                  </PopoverTrigger>
                  <PopoverContent className="w-80 p-4">
                    <div className="space-y-4">
                      <h4 className="text-sm font-medium">Text Size</h4>
                      <div className="flex items-center space-x-2">
                        <span className="text-xs">Small</span>
                        <Slider 
                          value={[fontSize]} 
                          min={12} 
                          max={36} 
                          step={1}
                          onValueChange={(values) => handleFontSizeChange(values[0])}
                          className="flex-1"
                        />
                        <span className="text-xs">Large</span>
                      </div>
                      <div className="grid grid-cols-2 gap-2">
                        {fontSizePresets.map((preset) => (
                          <Button
                            key={preset.name}
                            variant="outline"
                            size="sm"
                            onClick={() => {
                              handleFontSizeChange(preset.size);
                              setShowFontSizeSlider(false);
                            }}
                            className={`text-xs ${fontSize === preset.size ? 'bg-slate-100' : ''}`}
                          >
                            {preset.name} ({preset.size}px)
                          </Button>
                        ))}
                      </div>
                    </div>
                  </PopoverContent>
                </Popover>
                
                {/* Font Family Dropdown */}
                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button 
                      variant="ghost" 
                      size="sm"
                      className="h-8 px-2 rounded-md hover:bg-slate-100 transition-colors flex items-center space-x-1"
                      title="Font Family"
                    >
                      <span className="text-xs font-bold text-slate-600">A</span>
                      <ChevronDown className="h-3 w-3" />
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent className="w-56">
                    {availableFonts.map((font) => (
                      <DropdownMenuItem
                        key={font.class}
                        onClick={() => handleFontFamilyChange(font.name)}
                        className="cursor-pointer"
                      >
                        <span style={{ fontFamily: font.name }}>{font.name}</span>
                      </DropdownMenuItem>
                    ))}
                  </DropdownMenuContent>
                </DropdownMenu>
                
                <div className="w-px h-5 bg-slate-200" />
                <Button 
                  variant="ghost" 
                  size="sm"
                  onClick={() => handleAlignment('left')}
                  className={`h-8 w-8 p-0 rounded-md hover:bg-slate-100 transition-colors ${textAlign === 'left' ? 'bg-slate-100' : ''}`}
                  title="Align Left"
                >
                  <AlignLeft className="h-4 w-4 text-slate-600" />
                </Button>
                <Button 
                  variant="ghost" 
                  size="sm"
                  onClick={() => handleAlignment('center')}
                  className={`h-8 w-8 p-0 rounded-md hover:bg-slate-100 transition-colors ${textAlign === 'center' ? 'bg-slate-100' : ''}`}
                  title="Align Center"
                >
                  <AlignCenter className="h-4 w-4 text-slate-600" />
                </Button>
                <Button 
                  variant="ghost" 
                  size="sm"
                  onClick={() => handleAlignment('right')}
                  className={`h-8 w-8 p-0 rounded-md hover:bg-slate-100 transition-colors ${textAlign === 'right' ? 'bg-slate-100' : ''}`}
                  title="Align Right"
                >
                  <AlignRight className="h-4 w-4 text-slate-600" />
                </Button>
                <div className="w-px h-5 bg-slate-200" />
                <Popover>
                  <PopoverTrigger asChild>
                    <Button
                      variant="ghost"
                      size="sm"
                      className="h-8 w-8 p-0 rounded-md hover:bg-slate-100 transition-colors"
                      title="Date Selection"
                    >
                      <Calendar className="h-4 w-4 text-slate-600" />
                    </Button>
                  </PopoverTrigger>
                  <PopoverContent className="w-auto p-0" align="start">
                    <CalendarComponent
                      mode="single"
                      selected={selectedDate}
                      onSelect={handleDateSelect}
                      initialFocus
                    />
                  </PopoverContent>
                </Popover>
                
                <div className="w-px h-5 bg-slate-200" />
                
                {/* Export dropdown */}
                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button 
                      variant="ghost" 
                      size="sm"
                      className="h-8 px-2 rounded-md hover:bg-slate-100 transition-colors flex items-center space-x-1"
                      title="Export journal entry"
                      disabled={isExporting}
                    >
                      <Download className="h-4 w-4 text-slate-600" />
                      {isExporting && <span className="ml-1 text-xs">Exporting...</span>}
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent>
                    <DropdownMenuItem onClick={() => exportJournalEntry('image')}>
                      <FileImage className="h-4 w-4 mr-2" />
                      <span>Export as Image</span>
                    </DropdownMenuItem>
                    <DropdownMenuItem onClick={() => exportJournalEntry('pdf')}>
                      <FileText className="h-4 w-4 mr-2" />
                      <span>Export as PDF</span>
                    </DropdownMenuItem>
                    <DropdownMenuItem onClick={() => exportJournalEntry('html')}>
                      <FileText className="h-4 w-4 mr-2" />
                      <span>Export as HTML</span>
                    </DropdownMenuItem>
                  </DropdownMenuContent>
                </DropdownMenu>
              </div>
              
              {/* Content area - Rich Text Editor with attached files */}
              <div className="flex-1 relative">
                {/* Editable content area */}
                <div
                  ref={contentEditableRef}
                  contentEditable
                  className={`w-full min-h-[40vh] outline-none p-0 text-slate-700 ${contentError ? 'border-red-500' : ''}`}
                  style={{
                    fontFamily: fontFamily,
                    fontSize: `${fontSize}px`,
                    textAlign: textAlign
                  }}
                  onInput={handleContentChange}
                  placeholder="Start writing your thoughts..."
                  dangerouslySetInnerHTML={{ __html: content }}
                />
                
                {/* Display attached files */}
                {attachedFiles.map((file) => (
                  <div
                    key={file.id}
                    className={`absolute inline-block ${isDraggingFile === file.id ? 'cursor-grabbing z-50' : 'cursor-grab'}`}
                    style={{
                      left: `${file.position?.x || 0}%`,
                      top: `${file.position?.y || 0}%`,
                      transform: 'translate(-50%, -50%)',
                      maxWidth: '80%',
                      zIndex: isDraggingFile === file.id ? 50 : 10
                    }}
                    onMouseDown={(e) => {
                      e.preventDefault();
                      handleFileDragStart(file.id);
                    }}
                    onMouseMove={(e) => handleFileDrag(e, file.id)}
                    onMouseUp={handleFileDragEnd}
                    onMouseLeave={handleFileDragEnd}
                  >
                    <div className="group relative rounded-md overflow-hidden border border-slate-200 bg-white shadow-sm">
                      {/* File content */}
                      {file.type.startsWith('image/') && (
                        <img 
                          src={file.url} 
                          alt={file.name}
                          className="max-w-full max-h-64 object-contain"
                        />
                      )}
                      {file.type.startsWith('video/') && (
                        <video 
                          controls
                          src={file.url}
                          className="max-w-full max-h-64"
                        />
                      )}
                      {file.type.startsWith('audio/') && (
                        <audio 
                          controls
                          src={file.url}
                          className="max-w-full w-64"
                        />
                      )}
                      {file.type.startsWith('application/pdf') && (
                        <div className="flex items-center space-x-2 p-3 bg-slate-50">
                          <FileText className="h-5 w-5 text-red-500" />
                          <span className="text-sm truncate">{file.name}</span>
                        </div>
                      )}
                      
                      {/* File toolbar */}
                      <div className="absolute top-1 right-1 opacity-0 group-hover:opacity-100 transition-opacity">
                        <Button
                          variant="ghost"
                          size="sm"
                          className="h-6 w-6 p-0 rounded-full bg-white/80 hover:bg-white text-red-500"
                          onClick={() => deleteAttachedFile(file.id)}
                        >
                          <X className="h-3 w-3" />
                        </Button>
                      </div>
                    </div>
                  </div>
                ))}
                
                {contentError && (
                  <p className="text-red-500 text-xs mt-1">{contentError}</p>
                )}
              </div>
              
              {/* Word count and last saved info */}
              <div className="text-xs text-slate-500 flex items-center justify-between">
                <div>
                  {wordCount} words · {charCount} characters
                  {attachedFiles.length > 0 && (
                    <span> · {attachedFiles.length} attachment{attachedFiles.length !== 1 ? 's' : ''}</span>
                  )}
                </div>
                <div>
                  {selectedDate && (
                    <span className="mr-3">{format(selectedDate, 'PPP')}</span>
                  )}
                  {lastSaved && (
                    <span>Last saved: {format(lastSaved, 'p')}</span>
                  )}
                </div>
              </div>
              
              {/* Bottom buttons */}
              <div className="flex justify-between items-center pt-4">
                {/* Enhance button (star icon) */}
                <Button
                  onClick={handleEnhance}
                  disabled={isEnhancing}
                  variant="ghost"
                  className="text-[#4285F4] hover:text-[#3367D6] transition-all p-2 hover:scale-110 hover:shadow-md rounded-full group"
                >
                  {isEnhancing ? (
                    <div className="relative">
                      <div className="absolute inset-0 flex items-center justify-center">
                        <div className="h-8 w-8 rounded-full overflow-hidden">
                          <div 
                            className="h-full bg-blue-200 transition-all duration-300" 
                            style={{ width: `${enhanceProgress}%` }}
                          />
                        </div>
                      </div>
                      <Star className="h-8 w-8 text-[#4285F4] fill-current animate-pulse relative z-10" />
                    </div>
                  ) : (
                    <Star className="h-8 w-8 fill-current transition-opacity group-hover:opacity-80" />
                  )}
                </Button>
                
                {/* Save button */}
                <Button 
                  onClick={() => handleSave(true)}
                  disabled={isSaving}
                  className="bg-[#4285F4] hover:bg-[#3367D6] text-white font-bold rounded-full px-10 py-6 transition-all hover:shadow-md font-serif text-lg relative overflow-hidden"
                >
                  {isSaving ? (
                    <>
                      <span className="opacity-0">Save</span>
                      <span className="absolute inset-0 flex items-center justify-center">
                        <div className="h-5 w-5 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                      </span>
                    </>
                  ) : (
                    "Save"
                  )}
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
};

export default JournalEntry;